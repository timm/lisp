;#!/usr/bin/env clisp -q
; vim: filetype=lisp: ts=2 sw=2 sts=1  et :

(defun l() 
  (handler-bind ((style-warning #'muffle-warning)) 
    (load "ethos")))

;---------.---------.---------.---------.--------.---------.----------
; test suite
(defstruct tests all)
(defparameter *tests* (make-tests))

(defmethod run ((te tests))
	(let (fail (n 0) (y 0))
		(dolist (one (tests-all te))
			(cond ((eval  one) (incf y))
						(t           (incf n)
												 (push one fail))))
		(when fail
			(mapc #'print fail)
			(format t "~%PASS = ~s FAIL = ~s~%"  y n))))

(defmethod build ((te tests) x)
	(pushnew x (tests-all te) :test #'equalp))

(defmacro eg (&body body) `(build *tests* ',@body))

(eg (equal t nil))

;---------.---------.---------.---------.--------.---------.----------
; hash defines
(defun stop ()
  #+sbcl (sb-ext:exit)
  #+:clisp (ext:exit))

(defun cli ()
		#+clisp ext:*args*
  #+sbcl sb-ext:*posix-argv*)

(defun the-slots (it)
  #+clisp (class-slots (class-of it))
  #+sbcl (sb-mop:class-slots (class-of it)))

;---------.---------.---------.---------.--------.---------.----------
; macros
(defmacro aif (test then &optional else)
	`(let ((a ,test)) (if a ,then ,else)))

(defmacro while (test &body body)
	`(do () ((not ,test)) ,@body))

(defmacro whale (test &body body )
	`(let (a)
		 (while (setf a ,test) ,@body)))

(defmacro doitems ((one n list &optional out) &body body )
	`(let ((,n -1))
		 (dolist (,one ,list ,out) (incf ,n) ,@body)))

(eg (let (out) 
			(doitems (x pos '(a b c) out) 
				(push `(,pos ,x) out))))

(defmacro do-hash ((key value  h &optional out) &body body )
	`(progn (maphash #'(lambda (,key ,value) ,@body) ,h) ,out))

(defmacro ? (obj first-slot &rest more-slots)
	(if (null more-slots)
		`(slot-value ,obj ',first-slot)
		`(? (slot-value ,obj ',first-slot) ,@more-slots)))

(defmacro ?? (&rest x) `(? *O* ,@x))

(defmacro do-read ((it &optional f out) &body body)
  (let ((str (gensym)))
    `(let (,it) 
       (if ,f
         (with-open-file (,str ,f)
           (while (setf ,it (read-line ,str nil))
             ,@body))
         (while (setf ,it (read-line *standard-input* nil))
           ,@body))
       ,out)))

(eg (let ((n 0))
			(do-read (x "ethos" (> n 0)) 
				(incf n (length x)))))

;---------.---------.---------.---------.--------.---------.----------
(defstruct ch!
  (meta  #\%)
  (less  #\<)
  (num   #\$)
  (more  #\>)
  (klass #\!)
  (skip  #\?)
  (sep   #\,))

(defstruct lsh!
  (poles 10)
  (trim  0.95))

(defstruct rands 
	(seed 			10013) 
	(seed1			10013) 
	(multiplier 16807.0d0)
	(modulus    2147483647.0d0))

(defstruct control 
  (rand (make-rands))
  (lsh  (make-lsh!))
  (ch   (make-ch!)))

(defun cli2options (thing)
  (dolist (x (cli) thing)
     (aif (find (format nil ":~a" x) (the-slots thing) :test #'equalp)
       (setf (slot-value thing x) 
             (read-from-string (nth (+ 1 a ) thing))))))

(defvar *O* (make-control))

(eg (eql #\% (?? ch meta)))

;---------.---------.---------.---------.--------.---------.----------
; tricks 
(defun print-list(lst sep  str)
  (format str "~a" (car lst))
  (dolist (x (cdr lst)) (format str "~a ~a" sep x)))

(defun list-string(lst &optional (sep ","))
  (with-output-to-string (str) (print-list lst sep str)))

(eg (equalp "A, B, C" (list-string '(a b c))))

(defun has (x &rest lst) 
  (dolist (y lst)
    (let ((x (if (stringp x) x (format nil "~a" x))))
      (if (find y x :test #'equal) 
        (return t)))))

(let ((whitespace '(#\, #\space #\tab #\newline)))
  (defun s->words (s &optional (sep whitespace))
    (with-input-from-string (str s)
      (let (tmp out)
        (labels 
          ((end-of-word () 
            (when tmp
              (push (concatenate 'string (reverse tmp)) out) 
              (setf tmp nil)) 
              out))
          (whale (read-char str nil)
                 (if (member a sep :test #'eql)
                     (end-of-word)
                     (push a tmp)))
          (reverse (end-of-word)))))))

(eg (equalp '("123" "456" "789") 
             (s->words "123,456 ,789  , ")))

(defun rand-reset (&optional seed)
	(setf (?? rand seed1) (or seed (?? rand seed))))

(defun rand (&optional (n 1)) 
	(with-slots (seed1 modulus multiplier) (?? rand)
		(setf seed1 (mod (* multiplier seed1)  modulus))
    (* n (- 1.0d0 (/ seed1 modulus)))))

(defun randi (&optional (n 100)) 
	(floor (* n (/ (rand 1000.0) 1000))))

;---------.---------.---------.---------.--------.---------.---------
; symbols
(defstruct sym
  (counts (make-hash-table))
  (n 0) (pos 0) (txt "") (w 1)
  (ent 0)
  (most 0)
  mode)

(defmethod spread ((s sym)) (ent s))
(defmethod mid ((s sym)) (sym-mode s))
(defmethod prep ((s sym) x) x)

(defmethod update ((s sym) x)
  (with-slots (most mode counts  n) s
    (incf n)
    (let ((new (incf (gethash x counts 0))))
      (if (> new most)
        (setf most new
              mode x)))
    x))

(defmethod dec ((s sym) x)
  (with-slots (n counts) s
    (unless (< n 1)
      (decf (gethash x counts 0))
      (decf n))))

(defmethod ent ((s sym) &aux (e 0))
  (with-slots (counts n) s
    (do-hash (k v counts e)
      (let ((p (/ v n)))
        (decf e (* p (log p 2)))))))

(defmethod dist ((s sym) s1 s2)
  (labels ((no (x) (eql x (?? ch skip))))
    (if (and (no s1) (no s2))
      1
      (if (eql s1 s2) 0 1))))

;---------.---------.---------.---------.--------.---------.----------
; numbers
(defstruct num 
  (n 0) (pos 0) (txt "") (w 1)
  (mu 0.0) (m2 0.0) (sd 0.0)
  (lo most-positive-fixnum)
  (hi most-negative-fixnum))

(defmethod spread ((s num)) (num-sd s))
(defmethod mid ((s num)) (num-mu s))
(defmethod prep ((s num) x) (if (numberp x) x (read-from-string x)))

(defmethod update ((nu num) (x string))
  (update nu (prep nu x)))

(defmethod update ((nu num) (x number))
  (with-slots (n lo hi mu m2) nu
    (let ((delta (- x mu)))
      (setf n  (+ 1 n)
            lo (min lo x)
            hi (max hi x)
            mu (+ mu (/ delta n))
            m2 (+ m2 (* delta (- x mu))))
      (sd-prim nu))
    x))

(defmethod dec ((nu num) x)
  (with-slots (n mu m2) nu
    (let ((delta (- x mu)))
      (setf n  (- n 1)
            mu (- mu (/ delta n))
            m2 (- m2 (* delta (- x mu))))
      (sd-prim nu))))

(defmethod sd-prim ((nu num))
  (with-slots (sd n m2) nu
    (setf sd (cond ((< n 2)  0)
                   ((< m2 0) 0)
                   (t  (sqrt (/ m2 (- n 1))))))))

(defmethod norm ((nu num) x)
  (with-slots (lo hi) nu
    (/ (- x lo) (+ (- hi lo) (/ 1 most-positive-fixnum)))))

(defmethod dist ((nu num) n1 n2)
  (labels ((no (x) (eql x (?? ch skip))))
    (cond ((and (no n1) (no n2)) (return-from dist 1))
          ((no n1) (setf n2 (norm nu n2)
                         n1 (if (< n1 0.5) 1 0)))
          ((no n2) (setf n1 (norm nu n1)
                         n2 (if (< n2 0.5) 1 0)))
          (t       (setf n1 (norm nu n1)
                         n2 (norm nu n2))))
    (abs (- n1 n2))))

(eg 
	(progn 
		(rand-reset)
		(let* ((max     1000)
					 (min     5)
					 (results (make-hash-table))
					 (n       (make-num))
					 (lst     (loop for i from 1 to max collect (rand))))
			(loop for i from 0 to (1- max)  do
						(if (> i (1- min))
							(push (spread n) (gethash i results)))
						(update n (nth i lst))
						)
			(loop for i from (1- max)  downto min do
						(dec n (nth i lst))
						(push (spread n) (gethash i results))
						)
			(let ((diff 0))
				(maphash #'(lambda (k v) 
										 (incf diff (-(first v) (second v))))
								 results)
				(< (abs diff) 0.0001)))))

;--------d.---------.---------.---------.--------.---------.----------
(defun all (lst &optional how)
  (dolist (one lst how)
	  (setf how 
       (or how (if (numberp one) (make-num) (make-sym))))
    (update how one)))

(eg (let ((x (all '( y y y y y y y y n n n n n))))
			(< 0.961 (spread x) 0.962)))

(eg (let ((x (all '(9 2 5 4 12 7 8 11 9 3 
                    7 4 12 5 4 10 9 6 9 4))))
        (and (< 3.05 (? x sd) 3.07)
						 (< 6.99 (? x mu) 7.01))))

;---------.---------.---------.---------.--------.---------.----------
; tables of data
(defstruct col (w 1) (pos 0) (txt ""))
(defstruct cols all klass goals names indep nums syms meta)
(defstruct row cells poles)
(defstruct data  rows (cols (make-cols)) (npoles 0))

(defmethod build ((c cols) lst)
  (with-slots (indep klass all names goals meta nums syms) c
    (doitems (x pos lst)
      (labels 
        ((goalp()  (has x (?? ch klass) (?? ch less) (?? ch more)))
         (nump()   (has x (?? ch num)   (?? ch less) (?? ch more)))
         (klassp() (has x (?? ch klass)))
         (metap()  (has x (?? ch meta)))
         (lessp()  (has x (?? ch less)))
         (skipp()  (has x (?? ch skip))))
        (unless (skipp)
          (push x names)
          (if (klassp) (setq klass pos))
          (let* ((w     (if (lessp) -1 1))
                 (todo  (if (nump) #'make-num #'make-sym))
                 (col   (funcall todo :pos pos :txt x :w w)))
            (push col all)
            (if (nump) (push col nums)  (push col syms))
            (if (metap)
              (push col meta)
              (if (goalp) (push col goals) (push col indep)))))))
    (reverse all)))

(build (make-cols) '($a  ?c  <e !f))

(defmethod update ((cs cols) lst)
  (dolist (col (? cs all) lst)
    (setf (nth (? col pos) lst)
          (update col (nth (? col pos) lst)))))

(defmethod update ((d data) lst)
  (if (? d cols names) 
    (let ((tmp (update (? d cols) lst)))
      (push (make-row :cells tmp) (data-rows d)))
    (build (? d cols) lst)))

(defmethod readd ((d data) &optional f)
   (do-read (x f)
     (update d (s->words x))))

(defmethod print-object ((d data) str)
  (print-list (? d cols names)  ","  str)
  (dotimes (i  (? d npoles)) 
    (format str ", %pole~a" i))
  (terpri str)
  (dolist (row (? d rows))
    (print-list (coerce (? row cells) 'list)  ","  str)
    (if (? row poles)
      (print-list (? row poles)  ","  str)
      (dotimes (i  (? d npoles)) 
        (format str ",0")))
    (terpri str)))

; a comment
'(let ((d (make-data)))
   (readd d "../data/weather.csv")
   (format t "~&~a" d))

(run *tests*)

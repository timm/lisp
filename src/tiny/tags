!	lib/macros.lisp	/^(defmacro ! (l x) `(cdr (assoc ',x ,l)))$/;"	f
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
*egs*	lib/egs.lisp	/^(defvar *egs* nil)$/;"	f
*seed*	lib/maths.lisp	/^(defvar *seed* 10013)$/;"	f
:tiny	tiny.lisp	/^(defpackage :tiny (:use :cl))$/;"	f
?	lib/macros.lisp	/^(defmacro ? (s x &rest xs)$/;"	f
R	Makefile	/^R=$(shell git rev-parse --show-toplevel)$/;"	m
add	col/num.lisp	/^(defmethod add ((i num) (lst cons)) (dolist (x lst i) (add i x)))$/;"	f
add	col/num.lisp	/^(defmethod add ((i num) x)$/;"	f
add	col/sample.lisp	/^(defmethod add ((i sample) (x number))$/;"	f
add	col/sym.lisp	/^(defmethod add ((i sym) (lst cons)) (dolist (x lst i) (add i x)))$/;"	f
add	col/sym.lisp	/^(defmethod add ((i sym) x)$/;"	f
add	row/rows.lisp	/^(defmethod add ((i rows) (lst cons)) (add i (make-row i lst)))$/;"	f
add	row/rows.lisp	/^(defmethod add ((i rows) (row1 row))$/;"	f
adds	col/sym.lisp	/^(defmethod adds ((i sym) x inc)$/;"	f
around	row/row.lisp	/^(defmethod around ((row1 row) rows)$/;"	f
better	row/row.lisp	/^(defmethod better ((row1 row) (row2 row))$/;"	f
car<	lib/lists.lisp	/^(defun car< (x) (lambda (a b) (< (car a) (car b))))$/;"	f
car>	lib/lists.lisp	/^(defun car> (x) (lambda (a b) (> (car a) (car b))))$/;"	f
cells	lib/strings.lisp	/^(defun cells (string &key (char #\\,)) (splits string :char char :filter #'thing))$/;"	f
charn	lib/strings.lisp	/^(defun charn (x) $/;"	f
cl1	todo.lisp	/^(defun cl1 (lst) $/;"	f
cli	lib/settings.lisp	/^(defun cli (key.flag.help.default)$/;"	f
clone	row/rows.lisp	/^(defmethod clone ((i rows) &optional src) $/;"	f
cols	col/cols.lisp	/^(defstruct+ cols names  ; list of column names$/;"	f
defstruct+	lib/structs.lisp	/^(defmacro defstruct+ (x &body body) $/;"	f
demos	lib/egs.lisp	/^(defun demos (settings all &optional one)$/;"	f
discretize	col/num.lisp	/^(defmethod discretize ((i num) x &optional (bins (? my bins)))$/;"	f
dist	col/num.lisp	/^(defmethod dist ((i num) x y)$/;"	f
dist	col/sym.lisp	/^(defmethod dist ((i sym) x y)$/;"	f
dist	row/rows.lisp	/^(defmethod dist ((self rows) (row1 row) (row2 row))$/;"	f
div	col/num.lisp	/^(defmethod div ((i num)) (div (? i _kept)))$/;"	f
div	col/sample.lisp	/^(defmethod div ((i sample)) (\/ (- (per i .9) (per i .1)) 2.58))$/;"	f
div	col/sym.lisp	/^(defmethod div ((i sym))$/;"	f
eg	lib/egs.lisp	/^(defmacro eg (what arg doc &rest src) $/;"	f
geta	lib/macros.lisp	/^(defmacro geta (x lst &optional (init 0))$/;"	f
gt	lib/lists.lisp	/^(defun gt (x) (lambda (a b) (> (slot-value a x) (slot-value b x))))$/;"	f
lines	lib/strings.lisp	/^(defun lines (string) (splits string :char   #\\Newline))$/;"	f
lt	lib/lists.lisp	/^(defun lt (x) (lambda (a b) (< (slot-value a x) (slot-value b x))))$/;"	f
make-cols	col/cols.lisp	/^(defun make-cols (lst)$/;"	f
make-num	col/num.lisp	/^(defun make-num (&optional (s "") (n 0)) $/;"	f
make-row	row/row.lisp	/^(defun make-row (cols l) (%make-row :cells l :_cols cols))$/;"	f
make-rows	row/rows.lisp	/^(defun make-rows (&optional src (i (%make-rows)))$/;"	f
make-sample	col/sample.lisp	/^(defun make-sample (&optional (max (! my keep))) $/;"	f
make-sym	col/sym.lisp	/^(defun make-sym (&optional s n) (%make-sym :txt s :at n))$/;"	f
mid	col/num.lisp	/^(defmethod mid ((i num)) (mid (? i _kept)))$/;"	f
mid	col/sample.lisp	/^(defmethod mid ((i sample)) (per i .5))$/;"	f
mid	col/sym.lisp	/^(defmethod mid ((i sym))$/;"	f
my	tiny.lisp	/^(defvar my (settings "$/;"	f
norm	col/num.lisp	/^(defmethod norm ((i num) x)$/;"	f
num	col/num.lisp	/^(defstruct+ num (txt "")  ; column name$/;"	f
parseHelp	todo.lisp	/^(defun parseHelp(str)$/;"	f
per	col/sample.lisp	/^(defmethod per ((i sample) p)$/;"	f
randf	lib/maths.lisp	/^(defun randf (&optional (n 1.0)) $/;"	f
randi	lib/maths.lisp	/^(defun randi (&optional (n 1)) (floor (* n (\/ (randf 1000000000.0) 1000000000))))$/;"	f
rnd	lib/maths.lisp	/^(defun rnd (number &optional (digits 3))$/;"	f
row	row/row.lisp	/^(defstruct+ row cells    ; cells $/;"	f
rows	row/rows.lisp	/^(defstruct+ rows rows   ; all the rows$/;"	f
sample	col/sample.lisp	/^(defstruct+ sample $/;"	f
setting	todo.lisp	/^(defun setting (flag.key.default)$/;"	f
settings	lib/settings.lisp	/^(defun settings (header options)$/;"	f
settings1	todo.lisp	/^(defun settings1(str)$/;"	f
sorted	col/sample.lisp	/^(defmethod sorted ((i sample))$/;"	f
splits	lib/strings.lisp	/^(defun splits (str &key (char #\\,) (filter #'identity))$/;"	f
sym	col/sym.lisp	/^(defstruct+ sym  (txt "")  ; column name$/;"	f
thing	lib/strings.lisp	/^(defun thing (x &aux (y (trim x)))$/;"	f
trim	lib/strings.lisp	/^(defun trim (x) (string-trim '(#\\Space #\\Tab #\\Newline) x))$/;"	f
want	Makefile	/^want = row\/row row\/rows col\/cols col\/num col\/sample col\/sym    \\$/;"	m
with-lines	lib/strings.lisp	/^(defun with-lines (file fun)$/;"	f
